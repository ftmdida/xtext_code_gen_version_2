/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.example.mydsl.myDslSample.Agent
import org.xtext.example.mydsl.myDslSample.Attacker
import org.xtext.example.mydsl.myDslSample.Defender
import org.xtext.example.mydsl.myDslSample.User
import org.xtext.example.mydsl.myDslSample.ProtocolCheck
import org.xtext.example.mydsl.myDslSample.HTTPMethodCheck
import org.xtext.example.mydsl.myDslSample.RegExpMatch
import org.xtext.example.mydsl.myDslSample.FrequencyCheck
import org.xtext.example.mydsl.myDslSample.HTTPParamLenCheck
import java.util.Iterator
import org.eclipse.emf.ecore.EObject

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslSampleGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
	 
	 for(e: resource.allContents.toIterable.filter(Defender)) {
		      
		      fsa.generateFile(
		      	e.filename + ".xml",
		      	e.compile_gen_xml_defender
		      );
		      
		      fsa.generateFile(
		      "jzombies/Defender.java",
		      e.compile_DefenderClass);
		      
		      fsa.generateFile(
		      "jzombies/Connection.java",
		      e.compile_Connection); 
		      
		      fsa.generateFile(
		      "jzombies/HttpMethod.java",
		      e.compile_HttpMethod); 
		      
		      fsa.generateFile(
		      "jzombies/Protocol.java",
		      e.compile_Protocol);    
		         
		      fsa.generateFile(
		      "jzombies/Request.java",
		      e.compile_Request); 
		      
		      fsa.generateFile(
		      "jzombies/Human.java",
		      e.compile_Human);

		       fsa.generateFile(
		      "jzombies/Zombie.java",
		      e.compile_Zombie);
		      
		      fsa.generateFile(
		      "jzombies/defender/Condition.java",
		      e.compile_Condition);
		      
		      fsa.generateFile(
		      "jzombies/defender/EndPoint.java",
		      e.compile_EndPoint);
		      
		      fsa.generateFile(
		      "jzombies/defender/SecurityPolicy.java",
		      e.compile_SecurityPolicy);
		      
		      fsa.generateFile(
		      "jzombies/defender/SecurityPolicyList.java",
		      e.compile_SecurityPolicyList);
		      
		      fsa.generateFile(
		      "jzombies/defender/action/Action.java",
		      e.compile_Action);
		      
		      fsa.generateFile(
		      "jzombies/defender/action/BlockSender.java",
		      e.compile_BlockSender);
		      
		      fsa.generateFile(
		      "jzombies/defender/action/DropRequest.java",
		      e.compile_DropRequest);
		      
		      fsa.generateFile(
		      "jzombies/defender/action/PassRequst.java",
		      e.compile_PassRequest);
		      
		      fsa.generateFile(
		      "jzombies/defender/condition/FrequencyCheck.java",
		      e.compile_FrequencyCheck);
		      
		      fsa.generateFile(
		      "jzombies/defender/condition/HttpMethodCheck.java",
		      e.compile_HttpMethodCheck);
		      
		      fsa.generateFile(
		      "jzombies/defender/condition/HttpParamLengthCheck.java",
		      e.compile_HttpParamLengthCheck);
		      
		      fsa.generateFile(
		      "jzombies/defender/condition/HttpRegExpMatchCheck.java",
		      e.compile_HttpRegExpMatchCheck);
		      
		      fsa.generateFile(
		      "jzombies/defender/condition/ProtocolCheck.java",
		      e.compile_ProtocolCheck);
		      
		      fsa.generateFile(
		      "jzombies/defender/condition/SubCondition.java",
		      e.compile_SubCondition);
		      
		      fsa.generateFile(
		      "jzombies/util/DefenderParser.java",
		      e.compile_DefenderParser);
		      
		      fsa.generateFile(
		      "jzombies/util/HttpDataParser.java",
		      e.compile_HttpDataParser);
		      
		      fsa.generateFile(
		      "jzombies/util/SecurityPolicyListParser.java",
		      e.compile_SecurityPolicyListParser);
		          
	    }
	 	 
	 for(e: resource.allContents.toIterable.filter(User)) {
		      fsa.generateFile(
		      "jzombies/User.java",
		      e.compile_User);   
		      
		       fsa.generateFile(
		      "jzombies/util/UserAndAttackerParser.java",
		      e.compile_UserAndAttackerParser);   
	    }
	 
	 for(e: resource.allContents.toIterable.filter(Attacker)) {
		      fsa.generateFile(
		      "jzombies/Attacker.java",
		      e.compile_AttackerClass);  
		      
		      fsa.generateFile(
		      "jzombies/util/UserAndAttackerParser.java",
		      e.compile_UserAndAttackerParser);    
		 
	    }		
	    
	    fsa.generateFile(
		      "users.xml",
		     	resource.compile_gen_xml_users);   
	    
	 for(e: resource.allContents.toIterable.filter(Agent)) {
		      fsa.generateFile(
		      "jzombies/Agent.java",
		     e.compile_AgentClass);   
		     
	    }		
		
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	}
	
	
	
	def compile(Resource resource) '''
	  public class {
	  }
	'''
	
	def compile_gen_xml_users(Resource resource) '''
	<?xml version="1.0" encoding="UTF-8"?>
	
	<!-- New XML document created with EditiX XML Editor (http://www.editix.com) at Thu Oct 29 21:15:45 CDT 2015 -->

	<users>
		«FOR e : resource.allContents.toIterable.filter(Agent)»
		«IF e instanceof User || e instanceof Attacker»
		<user name="«e.name»" sourceIP="«e.source.byte1 + "." + e.source.byte2 +"."+  e.source.byte3+"."+ e.source.byte4»" type="«e.type»">
			<requestList>
			«IF e instanceof User»
			«FOR req:(e as User).requests»
				<request>
					<source>«req.source.byte1 + "." + req.source.byte2 +"."+  req.source.byte3+"."+ req.source.byte4»</source>
					<destination>«req.destination.byte1 + "." + req.destination.byte2 +"."+  req.destination.byte3+"."+ req.destination.byte4»</destination>
					<protocol>«req.protocol.name()»</protocol>
					<port>«req.port»</port>
					<data>«req.data.replace("&","&amp;")»
					</data>
				</request>
			«ENDFOR»
			«ENDIF»
			
			«IF e instanceof Attacker»
			«FOR req:(e as Attacker).requests»
				<request>
					<source>«req.source.byte1 + "." + req.source.byte2 +"."+  req.source.byte3+"."+ req.source.byte4»</source>
					<destination>«req.destination.byte1 + "." + req.destination.byte2 +"."+  req.destination.byte3+"."+ req.destination.byte4»</destination>
					<protocol>«req.protocol.name()»</protocol>
					<port>«req.port»</port>
					<data>«req.data.replace("&","&amp;")»
					</data>
				</request>
			«ENDFOR»
			«ENDIF»
			</requestList>
		</user>
		«ENDIF»
		«ENDFOR»
	</users>
	'''
	
	def compile_gen_xml_defender(Defender e) '''
	  <?xml version="1.0" encoding="UTF-8"?>

	  <!-- New XML document created with EditiX XML Editor (http://www.editix.com) at Fri Oct 30 09:32:34 CDT 2015 -->
	  <defender name="«e.name»" sourceIP="«e.source.byte1 + "." + e.source.byte2 +"."+  e.source.byte3+"."+ e.source.byte4»">
		  <securityPolicyList>
		  	«e.compile_gen_xml_defender_securityPolicyList»
		  </securityPolicyList>	
	  </defender>	
	'''
	
	def compile_gen_xml_defender_securityPolicyList(Defender e) '''
	
	  	«FOR sp: e.securityPolicylist.securityPolicies»
	  		<securityPolicy name="«sp.name»">
				<endpoint>
				 	<protocol>«sp.endPoint.protocol.name()»</protocol>
				 	<port>«sp.endPoint.port»</port>
				 </endpoint>
				 
				<trueAction>
					«FOR ac: sp.trueActionList»
					<action type="«ac.action»"/>
					«ENDFOR»
				</trueAction>
				<falseAction>
					«FOR ac: sp.falseActionList»
					<action type="«ac.action»"/>
					«ENDFOR»
				</falseAction>
				
				<policy>
					«FOR cond: sp.conditionlist»
						<condition name="«cond.name»" />
					«ENDFOR»
					<operationList>
						
							«FOR operation:sp.operationList»
								<operator>
									«operation.toString.replaceAll("&","&amp;")»
								</operator>
							«ENDFOR»
						
					</operationList>
				</policy>
			</securityPolicy>
		«ENDFOR»
			<conditionList>
				«FOR cond: e.securityPolicylist.conditions»
					<condition name="«cond.name»">
						«FOR subCond: cond.subConditionList»
							<subcondition name="«subCond.name»">
								«IF subCond instanceof ProtocolCheck»
									«(subCond as ProtocolCheck).value.name()»
								«ENDIF»
								«IF subCond instanceof HTTPMethodCheck»
									«(subCond as HTTPMethodCheck).value»
								«ENDIF»
								«IF subCond instanceof RegExpMatch»
									«(subCond as RegExpMatch).value»
								«ENDIF»
								«IF subCond instanceof FrequencyCheck»
									«(subCond as FrequencyCheck).value»
								«ENDIF»
								«IF subCond instanceof HTTPParamLenCheck»
									«(subCond as HTTPParamLenCheck).value»
								«ENDIF»
							</subcondition>
						«ENDFOR»
					</condition>
				«ENDFOR»
			</conditionList>
	'''
	
	def compile_AttackerClass(Agent e)'''
		package jzombies;
		
		
		
		import java.util.ArrayList;
		
		import repast.simphony.engine.schedule.ScheduledMethod;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.grid.Grid;
		
		/***
		 * 
		 * This class is a subclass of 
		 * Agent class that represents an attacker
		 * who sends malicious requests to the defender
		 *
		 */
		public class Attacker extends Agent {
		
			private ContinuousSpace<Object> space;
			private Grid<Object> grid;
			ArrayList<Request> listOfRequests;
			Defender defender;
			int sentCounter = 0;
		
			
			/***
			 * 
			 * @param space is ContinuousSpace
			 * @param grid is Grid
			 * @param sourceIP is ip address of the Attacker
			 */
			public Attacker(ContinuousSpace<Object> space, Grid<Object> grid, String sourceIP ) {
				super(sourceIP);
				this.space = space;
				this.grid = grid;
				listOfRequests=new ArrayList<Request>();
			}
		
		
			/**
			 *
			 * This is the step behavior.
			 * step here you can check your variables for statistics.
			 * Schedule the step method for agents.  
			 * The method is scheduled starting at tick one with an interval of 1 tick.  
			 * Specifically, the step starts at 1, and
			 * and recurs at 1,2,3,...etc. This method also helps to simulate sending request. 
			 */
			@ScheduledMethod(start=1,interval=1)
			public void step() {
				if(sentCounter < listOfRequests.size()){
					send(listOfRequests.get(sentCounter++));
				}
			
			}
			@Override
			public void send(Request request) {
				defender.receive(request);		
			}
		
			@Override
			public void receive(Request request) {
				// TODO Auto-generated method stub
				
			}
		
			@Override
			public void connect(Agent agent) {
				defender = (Defender) agent;		
				agent.connect(this);
			}
			
			
			/***
			 * This function will add the attacker request
			 * into the sending list.
			 * @param req is Request
			 */
			public void addRequest(Request req){
				listOfRequests.add(req);
			}
		
		}
	'''
	def compile_AgentClass (Agent e)'''
		package jzombies;

		/**
		 * 
		 *This class represents the base for
		 *all the agents; user, defender, and attacker. 
		 */
		
		public abstract class Agent implements Connection {
			protected String sourceIP;
			
			/***
			 * Parameterized constructor
			 * @param sourceIP is the agent's ip address
			 */
			public Agent(String sourceIP) {
				this.sourceIP=sourceIP;
			}
		
		
			public String getSourceIP(){
				return sourceIP;
			}
			
		}
		
	'''	
	def compile_DefenderClass (Agent e)'''
			package jzombies;
		
		import java.util.ArrayList;
		
		import jzombies.defender.SecurityPolicyList;
		import jzombies.defender.action.Action;
		import repast.simphony.engine.watcher.Watch;
		import repast.simphony.engine.watcher.WatcherTriggerSchedule;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.grid.Grid;
		
		
		/***
		 * 
		 * This class is a subclass of 
		 * Agent class that represents a defender
		 * who receives the request from user and attacker,
		 * and verifies request against the security policies and
		 * take the appropriate action. 
		 */
		
		public class Defender extends Agent{
			private ContinuousSpace<Object> space;
			private Grid<Object> grid;
			private boolean moved;
			ArrayList<Agent> connections;
			SecurityPolicyList securityPolicList;
			
			/***
			 * 
			 * @param space is ContinuousSpace
			 * @param grid is Grid
			 * @param sourceIP is ip address of the defender
			 */
			public Defender(ContinuousSpace<Object> space, Grid<Object> grid, String sourceIP) {
				super(sourceIP);
				connections = new ArrayList<Agent>();
				this.space = space;	
				this.grid = grid;
			}
		
			@Watch(watcheeClassName = "jzombies.Zombie", watcheeFieldNames = "moved", 
					query = "within_vn 1", whenToTrigger = WatcherTriggerSchedule.IMMEDIATE)
			public void run() {
		
			}
			
			/***
			 * This function will set the security policy list
			 * into the defender.
			 * @param secpls is SecurityPolicyList
			 */
			public void setSecurityPolicyList(SecurityPolicyList secpls){
				this.securityPolicList = secpls; 
			}
			
			
			@Override
			public void connect(Agent agent) {
				connections.add(agent);
			}
		
			@Override
			public void send(Request request) {
				
				for (Agent agent : connections) {
					if(agent.getSourceIP() == request.getSourceIP()){
						agent.receive(request);
						break;
					}
				}
			}
		
			@Override
			public void receive(Request request) {
					
				ArrayList<Action> actions = securityPolicList.verify(request);
			
				for (Action action : actions) {
					action.execute(request);
				}
				
			}
		}
	'''
	def compile_Connection (Agent e)'''
		package jzombies;
		
		
		/***
		 * 
		 * This is an interface that helps to 
		 * make the connection between the agents. 
		 *
		 */
		public interface Connection {
			/***
			 * This function will connect the source agent 
			 * to defender.
			 * @param agent is Agent 
			 */
			void connect(Agent agent);
			
			/***
			 * This function will send the request 
			 * from the sender agent to defender.
			 * @param request
			 */
			void send(Request request);
			
			/***
			 * This function will receive the response 
			 * from the defender.
			 * @param request
			 */
			void receive(Request request);
		}
	'''
	def compile_HttpMethod(Agent e) '''
		package jzombies;
		
		/***
		 * This is an enumeration for Http Methods
		 * that represents a method which can be either
		 * GET,POST,HEAD,DELETE,PUT 
		 *
		 */
		public enum HttpMethod {
			GET,POST,HEAD,DELETE,PUT
		}
	'''
	def compile_Builder(Agent e) '''
		package jzombies;
		
		import java.io.IOException;
		import java.util.ArrayList;
		
		import javax.xml.parsers.ParserConfigurationException;
		
		import org.xml.sax.SAXException;
		
		import jzombies.util.DefenderParser;
		import jzombies.util.UserAndAttackerParser;
		import repast.simphony.context.Context;
		import repast.simphony.context.space.continuous.ContinuousSpaceFactory;
		import repast.simphony.context.space.continuous.ContinuousSpaceFactoryFinder;
		import repast.simphony.context.space.graph.NetworkBuilder;
		import repast.simphony.context.space.grid.GridFactory;
		import repast.simphony.context.space.grid.GridFactoryFinder;
		import repast.simphony.dataLoader.ContextBuilder;
		import repast.simphony.engine.environment.RunEnvironment;
		import repast.simphony.parameter.Parameters;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.continuous.NdPoint;
		import repast.simphony.space.continuous.RandomCartesianAdder;
		import repast.simphony.space.graph.Network;
		import repast.simphony.space.grid.Grid;
		import repast.simphony.space.grid.GridBuilderParameters;
		import repast.simphony.space.grid.SimpleGridAdder;
		import repast.simphony.space.grid.WrapAroundBorders;
		
		public class JZombiesBuilder implements ContextBuilder<Object> {
		
			/*
			 * (non-Javadoc)
			 * 
			 * @see
			 * repast.simphony.dataLoader.ContextBuilder#build(repast.simphony.context
			 * .Context)
			 */
			@Override
			public Context build(Context<Object> context) {
				context.setId("jzombies");
		
				NetworkBuilder<Object> netBuilder = new NetworkBuilder<Object>(
						"infection network", context, false);
				netBuilder.buildNetwork();
				
				
				
				ContinuousSpaceFactory spaceFactory = ContinuousSpaceFactoryFinder
						.createContinuousSpaceFactory(null);
				ContinuousSpace<Object> space = spaceFactory.createContinuousSpace(
						"space", context, new RandomCartesianAdder<Object>(),
						new repast.simphony.space.continuous.WrapAroundBorders(), 50,
						50);
		
				GridFactory gridFactory = GridFactoryFinder.createGridFactory(null);
				Grid<Object> grid = gridFactory.createGrid("grid", context,
						new GridBuilderParameters<Object>(new WrapAroundBorders(),
								new SimpleGridAdder<Object>(), true, 50, 50));
				
				Network<Object> net = (Network<Object>)context.getProjection("infection network"); 
				
				Parameters params = RunEnvironment.getInstance().getParameters();
				
				DefenderParser def= new DefenderParser();
				Defender defender;
				
				try {
					defender = def.parseDefender(space, grid);
					context.add(defender);
					
					UserAndAttackerParser users= new UserAndAttackerParser();
					ArrayList<Agent> agentsList = new ArrayList<Agent>();
					try {
						agentsList=users.parseUsers(space, grid);
					} catch (ParserConfigurationException | SAXException | IOException e) {
						e.printStackTrace();
					}
					
					for (Agent agent : agentsList) {
						if(agent instanceof User){
								net.addEdge(agent, defender);
								agent.connect(defender);
								context.add(agent);			
						}
						else {
								net.addEdge(agent,defender);
								agent.connect(defender);
								context.add(agent);
						}
					}
				} catch (ParserConfigurationException | SAXException | IOException e1) {
					e1.printStackTrace();
				}
				
		
				
		
				for (Object obj : context) {
					NdPoint pt = space.getLocation(obj);
					grid.moveTo(obj, (int) pt.getX(), (int) pt.getY());
				}
				
				if (RunEnvironment.getInstance().isBatch()) {
					RunEnvironment.getInstance().endAt(20);
				}
		
				return context;
			}
		}
	'''
	def compile_Protocol(Agent e)'''
		package jzombies;
		
		
		/***
		 * This is an enumeration for Protocols
		 * that represents a protocol which can be either
		 * HTTP, HTTPS, FTP, SSH
		 *
		 */
		public enum Protocol {
			
			HTTP(80), HTTPS(443), FTP(21) , SSH(22);
			
			private int protocol;
		
			private Protocol(int s) {
				protocol = s;
			}
		
			public int getStatusCode() {
				return protocol;
			}
		}
	'''
	def compile_Request(Agent e)'''
		package jzombies;
		
		/***
		 * 
		 * This class is a simple TCP request 
		 *
		 */
		public class Request {
			String sourceIP;
			String destinationIP;
			int port;
			String data;
			Protocol protocol;
			
			/***
			 * 
			 * @param sourceIP is sender ip address
			 * @param destinationIP destination ip address
			 * @param port is port number used by this request. 
			 * @param data is the message carried by this request
			 * @param protocol is the protocol used by this request. 
			 */
			public Request(String sourceIP, String destinationIP, int port,
					String data, Protocol protocol) {
				this.sourceIP = sourceIP;
				this.destinationIP = destinationIP;
				this.port = port;
				this.data = data;
				this.protocol = protocol;
			}
		
		
			public String getSourceIP(){
				return sourceIP;
			}
		
		
			public String getDestinationIP() {
				return destinationIP;
			}
		
		
			public void setDestinationIP(String destinationIP) {
				this.destinationIP = destinationIP;
			}
		
		
			public int getPort() {
				return port;
			}
		
		
			public void setPort(int port) {
				this.port = port;
			}
		
		
			public String getData() {
				return data;
			}
		
		
			public void setData(String data) {
				this.data = data;
			}
		
		
			public Protocol getProtocol() {
				return protocol;
			}
		
		
			public void setProtocol(Protocol protocol) {
				this.protocol = protocol;
			}
		
		
			public void setSourceIP(String sourceIP) {
				this.sourceIP = sourceIP;
			}
		}
	'''
	def compile_User(Agent e)'''
		package jzombies;
		
		import java.util.ArrayList;
		
		import repast.simphony.engine.schedule.ScheduledMethod;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.grid.Grid;
		
		
		/***
		 * 
		 * This class is a subclass of 
		 * Agent class that represents a user
		 * who sends normal requests to the defender
		 *
		 */
		public class User extends Agent {
			private ContinuousSpace<Object> space;
			private Grid<Object> grid;
			Defender defender;
			ArrayList<Request> listOfRequests;
			int sentCounter = 0;
		
			/***
			 * 
			 * @param space is ContinuousSpace
			 * @param grid is Grid
			 * @param sourceIP is ip address of the user
			 */
			public User(ContinuousSpace<Object> space, Grid<Object> grid, String sourceIP) {
				super(sourceIP);
				this.space = space;
				this.grid = grid;
				listOfRequests=new ArrayList<Request>();
				
			}
		
			/**
			 *
			 * This is the step behavior.
			 * step here you can check your variables for statistics.
			 * Schedule the step method for agents.  
			 * The method is scheduled starting at tick one with an interval of 1 tick.  
			 * Specifically, the step starts at 1, and
			 * and recurs at 1,2,3,...etc. This method also helps to simulate sending request. 
			 */
			@ScheduledMethod(start=1,interval=1)
			public void step() {
				if(sentCounter < listOfRequests.size()){
					send(listOfRequests.get(sentCounter++));
				}
			}
		
			@Override
			public void send(Request request) {
				defender.receive(request);
			}
		
			@Override
			public void receive(Request request) {
				// TODO Auto-generated method stub
		
			}
		
			@Override
			public void connect(Agent agent) {
				// TODO Auto-generated method stub
				defender = (Defender) agent;
				agent.connect(this);
			}
			
			/***
			 * This function will add the user request
			 * into the sending list.
			 * @param req is Request
			 */
			public void addRequest(Request req){
				listOfRequests.add(req);
			}
		
		}
	'''
	def compile_Human(Agent e)'''
		package jzombies;

		import java.util.List;
		
		import repast.simphony.engine.watcher.Watch;
		import repast.simphony.engine.watcher.WatcherTriggerSchedule;
		import repast.simphony.query.space.grid.GridCell;
		import repast.simphony.query.space.grid.GridCellNgh;
		import repast.simphony.random.RandomHelper;
		import repast.simphony.space.SpatialMath;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.continuous.NdPoint;
		import repast.simphony.space.grid.Grid;
		import repast.simphony.space.grid.GridPoint;
		import repast.simphony.util.SimUtilities;
		
		/**
		 * @author nick
		 *
		 */
		public class Human {
			
			private ContinuousSpace<Object> space;
			private Grid<Object> grid;
			private int energy, startingEnergy;
		
			public Human(ContinuousSpace<Object> space, Grid<Object> grid, int energy) {
				this.space = space;
				this.grid = grid;
				this.energy = startingEnergy = energy;
			}
			
			@Watch(watcheeClassName = "jzombies.Zombie", watcheeFieldNames = "moved", 
					query = "within_vn 1", whenToTrigger = WatcherTriggerSchedule.IMMEDIATE)
			public void run() {
		//		// get the grid location of this Human
		//		GridPoint pt = grid.getLocation(this);
		//
		//		// use the GridCellNgh class to create GridCells for
		//		// the surrounding neighborhood.
		//		GridCellNgh<Zombie> nghCreator = new GridCellNgh<Zombie>(grid, pt,
		//				Zombie.class, 1, 1);
		//		List<GridCell<Zombie>> gridCells = nghCreator.getNeighborhood(true);
		//		SimUtilities.shuffle(gridCells, RandomHelper.getUniform());
		//
		//		GridPoint pointWithLeastZombies = null;
		//		int minCount = Integer.MAX_VALUE;
		//		for (GridCell<Zombie> cell : gridCells) {
		//			if (cell.size() < minCount) {
		//				pointWithLeastZombies = cell.getPoint();
		//				minCount = cell.size();
		//			}
		//		}
		//		
		//		if (energy > 0) {
		//			moveTowards(pointWithLeastZombies);
		//		} else {
		//			energy = startingEnergy;
		//		}
			}
			
			public void moveTowards(GridPoint pt) {
				// only move if we are not already in this grid location
				if (!pt.equals(grid.getLocation(this))) {
					NdPoint myPoint = space.getLocation(this);
					NdPoint otherPoint = new NdPoint(pt.getX(), pt.getY());
					double angle = SpatialMath.calcAngleFor2DMovement(space, myPoint, otherPoint);
					space.moveByVector(this, 2, angle, 0);
					myPoint = space.getLocation(this);
					grid.moveTo(this, (int)myPoint.getX(), (int)myPoint.getY());
					//energy--;
				}
			}
		
		}
	'''
	def compile_Zombie(Agent e)	'''
			/**
		 * 
		 */
		package jzombies;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import repast.simphony.context.Context;
		import repast.simphony.engine.schedule.ScheduledMethod;
		import repast.simphony.random.RandomHelper;
		import repast.simphony.space.SpatialMath;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.continuous.NdPoint;
		import repast.simphony.space.graph.Network;
		import repast.simphony.space.grid.Grid;
		import repast.simphony.space.grid.GridPoint;
		import repast.simphony.util.ContextUtils;
		
		/**
		 * @author nick
		 * 
		 */
		public class Zombie {
		
			private ContinuousSpace<Object> space;
			private Grid<Object> grid;
			private boolean moved;
		
			public Zombie(ContinuousSpace<Object> space, Grid<Object> grid) {
				this.space = space;
				this.grid = grid;
			}
		
			@ScheduledMethod(start = 1, interval = 1)
			public void step() {
		//		// get the grid location of this Zombie
		//		GridPoint pt = grid.getLocation(this);
		//
		//		// use the GridCellNgh class to create GridCells for
		//		// the surrounding neighborhood.
		//		GridCellNgh<Human> nghCreator = new GridCellNgh<Human>(grid, pt,
		//				Human.class, 1, 1);
		//		List<GridCell<Human>> gridCells = nghCreator.getNeighborhood(true);
		//		SimUtilities.shuffle(gridCells, RandomHelper.getUniform());
		//
		//		GridPoint pointWithMostHumans = null;
		//		int maxCount = -1;
		//		for (GridCell<Human> cell : gridCells) {
		//			if (cell.size() > maxCount) {
		//				pointWithMostHumans = cell.getPoint();
		//				maxCount = cell.size();
		//			}
		//		}
		//		moveTowards(pointWithMostHumans);
		//		infect();
			}
		
			public void moveTowards(GridPoint pt) {
				// only move if we are not already in this grid location
				if (!pt.equals(grid.getLocation(this))) {
					NdPoint myPoint = space.getLocation(this);
					NdPoint otherPoint = new NdPoint(pt.getX(), pt.getY());
					double angle = SpatialMath.calcAngleFor2DMovement(space, myPoint,
							otherPoint);
					space.moveByVector(this, 1, angle, 0);
					myPoint = space.getLocation(this);
					grid.moveTo(this, (int) myPoint.getX(), (int) myPoint.getY());
					moved = true;
				}
			}
		
			public void infect() {
				GridPoint pt = grid.getLocation(this);
				List<Object> humans = new ArrayList<Object>();
				for (Object obj : grid.getObjectsAt(pt.getX(), pt.getY())) {
					if (obj instanceof Human) {
						humans.add(obj);
					}
				}
		
				if (humans.size() > 0) {
					int index = RandomHelper.nextIntFromTo(0, humans.size() - 1);
					Object obj = humans.get(index);
					NdPoint spacePt = space.getLocation(obj);
					Context<Object> context = ContextUtils.getContext(obj);
					context.remove(obj);
					Zombie zombie = new Zombie(space, grid);
					context.add(zombie);
					space.moveTo(zombie, spacePt.getX(), spacePt.getY());
					grid.moveTo(zombie, pt.getX(), pt.getY());
					
					Network<Object> net = (Network<Object>)context.getProjection("infection network");
					
					net.addEdge(this, zombie);
					
				}
			}
		}
	'''
	def compile_Condition(Agent e)'''
		package jzombies.defender;
		
		import java.util.ArrayList;
		import jzombies.Request;
		import jzombies.defender.condition.SubCondition;
		
		
		/***
		 * 
		 * This class is a core components for building 
		 * security policies which compose of one or more subconditions
		 *
		 */
		public class Condition {
			ArrayList<SubCondition> subConditions;
			
			public Condition(){
				this.subConditions= new ArrayList<SubCondition> ();
			}
		
			public ArrayList<SubCondition> getCondition() {
				return subConditions;
			}
		
			public void setSubCondition(ArrayList<SubCondition> scondition) {
				this.subConditions = scondition;
			}
			
		/***
		 * This method helps to add the subconditions for the corresponding condition. 
		 * @param cond is SubCondition
		 */
			public void addSubCondition(SubCondition cond){
				subConditions.add(cond);
			}
			
			/***
			 * This function will check all the subconditions
			 * and return the result of them. 
			 * @param r is Resulst
			 * @return boolean variable : true or false 
			 */
			public boolean getResultsOfAllSubConditions(Request r){
				boolean results = true;
				
				for (SubCondition scondition : subConditions) {
					results &= scondition.check(r);
				}
				return results;
			}
		
		
		}
	'''
	def compile_EndPoint(Agent e)'''
		package jzombies.defender;
		
		import jzombies.Protocol;
		/**
		 * End point represent a port and protocol 
		 * @author User-Zero
		 *
		 */
		public class EndPoint {
			int port;
			Enum<Protocol> protocol;
			
			
			public int getPort() {
				return port;
			}
			
			public void setPort(int port) {
				this.port = port;
			}
			public Enum<Protocol> getProtocol() {
				return protocol;
			}
			public void setProtocol(Enum<Protocol> protocol) {
				this.protocol = protocol;
			}
		}
	'''
	def compile_SecurityPolicy(Agent e)'''
		package jzombies.defender;

		import java.util.ArrayList;
		import java.util.List;
		
		import jzombies.Request;
		import jzombies.defender.action.Action;
		/**
		 * Security policy represent a rule that enforced on the incoming requests 
		 * for a specific end point.
		 * @author User-Zero
		 *
		 */
		public class SecurityPolicy {
			EndPoint endPoint;
			String policy;
			ArrayList<Condition> conditionList;
			ArrayList<String> operationList;
		
			ArrayList<Action> truePortionActionList;
			ArrayList<Action> falsePortionActionList;
		
			/**
			 * Parameterized constructor 
			 * @param endPoint The end point that this security policy will be 
			 * enforced on. 
			 * @param truePortionActionList The action(s) in case the request met
			 *  the security policy.
			 * @param falsePortionActionList The action(s) in case the request 
			 *  doesn't meet the security policy.
			 */
			public SecurityPolicy(EndPoint endPoint,
					ArrayList<Action> truePortionActionList,
					ArrayList<Action> falsePortionActionList) {
				this.endPoint = endPoint;
				this.truePortionActionList = truePortionActionList;
				this.falsePortionActionList = falsePortionActionList;
				conditionList= new ArrayList<Condition>();
			}
		
			public EndPoint getEndPoint() {
				return endPoint;
			}
		
			public void setEndPoint(EndPoint endPoint) {
				this.endPoint = endPoint;
			}
		
			public String getPolicy() {
				return policy;
			}
		
			public void setPolicy(String policy) {
				this.policy = policy;
			}
		
			public List<Condition> getCondition() {
				return conditionList;
			}
		
			public void setConditon(ArrayList<Condition> condition) {
				this.conditionList = condition;
			}
		
			/**
			 * Using this function you can create security rule with multiple 
			 * conditions, but you have to send list of operations in case more
			 * than one condition get used. 
			 * @param condition Condition
			 */
			public void addCondition(Condition condition) {
				this.conditionList.add(condition);
			}
		
			/**
			 * This function will verify it certain request meet a security policy
			 * @param req In coming request
			 * @return return True if the request met the rule(s) otherwise false.
			 * 
			 */
			public ArrayList<Action> enforce(Request req) {
				boolean result = true;
				
				/*if(req.getProtocol() != endPoint.getProtocol() || req.getPort() != endPoint.getPort())
					return new ArrayList<Action>();
				*/
				if (operationList.size() > 0) {
					result = conditionList.get(0).getResultsOfAllSubConditions(req);
					for (int i = 1; i < conditionList.size(); i++) {
						if (operationList.get(i - 1).contains("&")) {
							result &= conditionList.get(i)
									.getResultsOfAllSubConditions(req);
						} else {
							result |= conditionList.get(i)
									.getResultsOfAllSubConditions(req);
						}
					}
		
				} else {
					result = conditionList.get(0).getResultsOfAllSubConditions(req);
				}
		
				return result ? truePortionActionList : falsePortionActionList;
			}
			
			/**
			 * In case of multiple conditions, list of the operators must be given 
			 * @param op List of operators [&amp; or |]
			 */
			public void setOperationList(ArrayList<String> op) {
				this.operationList = op;
			}
		
		}
	'''
	def compile_SecurityPolicyList(Agent e)'''
		package jzombies.defender;

		import java.io.IOException;
		import java.util.ArrayList;
		import java.util.List;
		
		import javax.xml.parsers.ParserConfigurationException;
		
		import org.xml.sax.SAXException;
		
		import jzombies.Protocol;
		import jzombies.Request;
		import jzombies.defender.action.Action;
		import jzombies.defender.action.BlockSender;
		import jzombies.defender.action.DropRequest;
		import jzombies.defender.action.PassRequst;
		import jzombies.defender.condition.SubCondition;
		import jzombies.defender.condition.ProtocolCheck;
		import jzombies.util.SecurityPolicyListParser;
		
		/**
		 * Represent core component for the defender class, this class will contain 
		 * all the security policies and conditions used in the defender to be enforced
		 * on the incoming requests.
		 * @author User-Zero
		 *
		 */
		public class SecurityPolicyList {
			List<SecurityPolicy> securityPolicyList;
			List<Condition>  conditionSubList;
			
			public SecurityPolicyList(){
				securityPolicyList = new ArrayList<SecurityPolicy>();
				conditionSubList = new ArrayList<Condition>();
				//buildSecurityPolicyList();
			}
			
			public List<SecurityPolicy> getSecurityPolicy() {
				return securityPolicyList;
			}
			public void setSecurityPolicy(List<SecurityPolicy> securityPolicy) {
				this.securityPolicyList = securityPolicy;
			}
			public List<Condition> getBehavior() {
				return conditionSubList;
			}
			public void setConditions(List<Condition> condition) {
				this.conditionSubList = condition;
			}
		
			public void addSecurityPolicy(SecurityPolicy sp) {
				securityPolicyList.add(sp);
				
			}
			/**
			 * 
			 * This method will make a call to defender xml file parser
			 * It will get the security policies and insert it into
			 * security policy list. In other words, this method will help to 
			 * build the security policy list for this project.
			 * 
			 */
			public void buildSecurityPolicyList(){
				
			}
			/**
			 * This function will verify if the incoming request meet all 
			 * security policies enforced on the same end point. 
			 * @param r incoming request
			 * @return True if request meet all the security policies otherwise false.
			 */
			public ArrayList<Action> verify(Request r){
				
				ArrayList<Action> list = new ArrayList<Action>();
				ArrayList<Action> temp ;
				
				for (SecurityPolicy securityPolicy : securityPolicyList) {
					temp = securityPolicy.enforce(r);
					for (Action action : temp) {// check this out
						if(!list.contains(action)){
							if(action instanceof DropRequest || action instanceof BlockSender){
								list.remove(new PassRequst());
								list.add(action);
							}
							else {
								if(!list.contains(new BlockSender()) && !list.contains(new DropRequest()) )
									list.add(action);
							}
						}
					}
				}
				return list;
				}
		
		}
	'''
	def compile_Action(Agent e)'''
		package jzombies.defender.action;
		
		import jzombies.Request;
		
		/**
		 * This Class defined the action that will be fired in case the incoming
		 * request meet or violate security policy 
		 * @author User-Zero
		 *
		 */
		public abstract class  Action {
			public abstract void execute(Request r);
			
			@Override
		public abstract boolean equals(Object obj);
		}
	'''
	def compile_BlockSender(Agent e)'''
		package jzombies.defender.action;

		import jzombies.Request;
		/**
		 * This action will block the sender and prevent any other incoming requests 
		 * from the same sender. 
		 * @author User-Zero
		 *
		 */
		public class BlockSender extends Action{
		
			@Override
			public void execute(Request r) {
				// TODO Auto-generated method stub
				System.out.println("Defender: Blocked incoming request from " +r.getSourceIP());
			}
		
			@Override
			public boolean equals(Object obj) {
				// TODO Auto-generated method stub
				if(obj instanceof BlockSender)
					return true;
				return false;
			}
		
		}
	'''
	def compile_DropRequest(Agent e)'''
		package jzombies.defender.action;

		import jzombies.Request;
		
		/**
		 * This action will drop the incoming request and send error code to the 
		 * sender.
		 * @author User-Zero
		 *
		 */
		public class DropRequest extends Action{
		
			@Override
			public void execute(Request r) {
				// TODO Auto-generated method stub
				System.out.println("Defender: Dropped incoming request from " +r.getSourceIP());
			}
		
			@Override
			public boolean equals(Object obj) {
				// TODO Auto-generated method stub
				if(obj instanceof DropRequest)
					return true;
		return false;
	}
}
	'''
	def compile_PassRequest(Agent e)'''
		package jzombies.defender.action;

		import jzombies.Request;
		/**
		 * This action will allow the incoming request to reach it's destination. 
		 * @author User-Zero
		 *
		 */
		public class PassRequst extends Action{
		
			@Override
			public void execute(Request r) {
				// TODO Auto-generated method stub
				System.out.println("Defender: Passed incoming request from " +r.getSourceIP());
			}
		
			@Override
			public boolean equals(Object obj) {
				// TODO Auto-generated method stub
				if(obj instanceof PassRequst)
					return true;
				return false;
			}
		}
	'''
	def compile_FrequencyCheck(Agent e)'''
		package jzombies.defender.condition;

		import java.util.HashMap;
		import java.util.Timer;
		import java.util.TimerTask;
		
		import jzombies.Request;
		
		/**
		 * This class will verify if the number of requests per user
		 * less than certain number within one second.
		 * @author User-Zero
		 *
		 */
		public class FrequencyCheck extends SubCondition{
			int maxNumberOfReqests;
			Object mylock;
			HashMap<String,Integer> reqCounter; 
			/**
			 * 
			 * @param maxNumberOfReqests The maximum number of requests per 
			 * user within one second.
			 */
			public FrequencyCheck(int maxNumberOfReqests) {
				// TODO Auto-generated constructor stub
				mylock = new Object();
				reqCounter = new HashMap<String,Integer>();
				this.maxNumberOfReqests = maxNumberOfReqests;
				
				Timer timer = new Timer();  //At this line a new Thread will be created
			    timer.schedule(new ScheduledTask(mylock,reqCounter), 1000); //delay in milliseconds
			}
			
			public class ScheduledTask extends TimerTask {
				Object mylock;
				HashMap<String, Integer> reqCounter;
				
				public ScheduledTask(Object mylock, HashMap<String, Integer> reqCounter ) {
					// TODO Auto-generated constructor stub
					this.mylock = mylock;
					this.reqCounter = reqCounter;
				}
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					synchronized (mylock) {	
						reqCounter.clear();
					}
				}
				
			}
			
			@Override
			public boolean check(Request r) {
				// TODO Auto-generated method stub
				synchronized (mylock) {
					if(reqCounter.containsKey(r.getSourceIP())){
						int numberOfReq = reqCounter.get(r.getSourceIP());
						if(numberOfReq >= maxNumberOfReqests | numberOfReq+1 >= maxNumberOfReqests)
							return false;
						
						reqCounter.put(r.getSourceIP(), ++numberOfReq);
					}else
						reqCounter.put(r.getSourceIP(),1);
				}
				return true;
			}
		
		}
	'''
	def compile_HttpMethodCheck(Agent e)'''
		package jzombies.defender.condition;

		import jzombies.HttpMethod;
		import jzombies.Request;
		import jzombies.util.HttpDataParser;
		import jzombies.util.HttpDataParser.HttpData;
		
		/**
		 * This class will check the method used in http request if it match 
		 * certain method or not.
		 * @author User-Zero
		 *
		 */
		public class HttpMethodCheck extends SubCondition{
		
			HttpMethod httpMethod;
			/**
			 * 
			 * @param method Http Method it can be [GET,POST,HEAD,PUT,DELETE]
			 */
			public HttpMethodCheck(HttpMethod method) {
				// TODO Auto-generated constructor stub
				this.httpMethod = method;
			}
			
			@Override
			public boolean check(Request r) {
				HttpDataParser d = new HttpDataParser();
				HttpData dd = d.parse(r.getData());
				HttpMethod httpMethod2 = dd.getMethod();
				
				if(httpMethod2 == this.httpMethod)
					return true;
				
				return false;
			}
		
		}
	'''
	def compile_HttpParamLengthCheck(Agent e) '''
		package jzombies.defender.condition;

		import java.util.Iterator;
		import java.util.Map;
		
		import jzombies.Request;
		import jzombies.util.HttpDataParser;
		import jzombies.util.HttpDataParser.HttpData;
		
		/**
		 * This Class will check the length of the parameter(s) in a http request
		 * if they are less or greater or equals to a certain length
		 * @author User-Zero
		 *
		 */
		public class HttpParamLengthCheck extends SubCondition {
		
			OpCode oc;
			int size;
			/**
			 * 
			 * @param opc Operation code [lessThan or greaterThan or equalsTo]
			 * @param size length 
			 */
			public HttpParamLengthCheck(OpCode opc, int size){
				this.oc = opc;
				this.size = size;
			}
			
			public enum OpCode{
				LessThan,
				GreaterThan,
				EqualsTo
			}
			
			@Override
			public boolean check(Request r) {
				// TODO Auto-generated method stub
				HttpDataParser d = new HttpDataParser();
				HttpData dd = d.parse(r.getData());
				
				 Iterator it = dd.getParam().entrySet().iterator();
				 while (it.hasNext()) {
				     Map.Entry pair = (Map.Entry)it.next();
				     int ca = ((String) pair.getValue()).length();
				     
				     switch(oc){
				     case EqualsTo: 
				    	 if( ca == size) break;
				    	 else
				    		 return false;
				     case LessThan: 
				    	 if ( ca  < size ) break;
				    	 else
				    		 return false;
				     case GreaterThan:
				    	 if( ca  > size ) break ;
				    	 else
				    		 return false;
				     }
				     
				     it.remove(); // avoids a ConcurrentModificationException
				 }
				
				return true;
			}
		
		}
	'''
	def compile_HttpRegExpMatchCheck(Agent e) '''
		package jzombies.defender.condition;

		import java.util.Iterator;
		import java.util.Map;
		import java.util.regex.Matcher;
		import java.util.regex.Pattern;
		
		import jzombies.Request;
		import jzombies.util.HttpDataParser;
		import jzombies.util.HttpDataParser.HttpData;
		
		/**
		 * This class will check if the parameters of http request match to 
		 * a certain regular expression or not.
		 * @author User-Zero
		 *
		 */
		public class HttpRegExpMatchCheck extends SubCondition {
		
			String regExp;
			
			public HttpRegExpMatchCheck(String regExp) {
				// TODO Auto-generated constructor stub
				
				this.regExp = regExp;
			}
			
			@Override
			public boolean check(Request r) {
				// TODO Auto-generated method stub
				// Create a Pattern object
			      Pattern patt = Pattern.compile(regExp);
		
			    // Now create matcher object.
			    Matcher m ;
			      
			    HttpDataParser d = new HttpDataParser();
				HttpData dd = d.parse(r.getData());
				
				 Iterator it = dd.getParam().entrySet().iterator();
				 while (it.hasNext()) {
				     Map.Entry pair = (Map.Entry)it.next();
				     m = patt.matcher(pair.getValue().toString());
				     
				     if(m.find())
				    	 return true;
				     it.remove();
				 }
			
				return false;
			}
		
		}
	'''
	def compile_ProtocolCheck(Agent e)'''
		package jzombies.defender.condition;

		import jzombies.Protocol;
		import jzombies.Request;
		
		/**
		 *This class will check if a request uses certain protocol.  
		 * @author User-Zero
		 *
		 */
		public class ProtocolCheck extends SubCondition {
			Protocol protocol;
			
			
			public ProtocolCheck(Protocol protocol) {
				this.protocol = protocol;
			}
			
			
			@Override
			public boolean check(Request r) {
				if(protocol.getStatusCode() == r.getProtocol().getStatusCode()){
					return true;
				}
				return false;
			}
		
		}
	'''
	def compile_SubCondition(Agent e)'''
		package jzombies.defender.condition;

		import jzombies.Request;
		
		
		public abstract class SubCondition {
			/**
			 * This function will verify if a request meet certain condition  
			 * @param r The request
			 * @return result of the condition
			 */
			public abstract boolean check(Request r) ;
	
}
	'''
	def compile_DefenderParser(Agent e)'''
		package jzombies.util;

		import java.io.IOException;
		
		import javax.xml.parsers.DocumentBuilder;
		import javax.xml.parsers.DocumentBuilderFactory;
		import javax.xml.parsers.ParserConfigurationException;
		
		import jzombies.Defender;
		
		import org.w3c.dom.Document;
		import org.w3c.dom.Element;
		import org.w3c.dom.Node;
		import org.w3c.dom.NodeList;
		import org.xml.sax.SAXException;
		
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.grid.Grid;
		
		/**
		 * This class will parse the defender.xml file,
		 * to find the defender
		 */
		public class DefenderParser{
			
			/**
			 * 
			 * This method will parse the defender.xml file,
			 * look for the defender
			 * @param space ContinuousSpace
			 * @param grid Grid
			 * @return an instance of Defender agent
			 * 
			 */
			public Defender parseDefender(ContinuousSpace<Object> space, Grid<Object> grid) throws ParserConfigurationException, SAXException, IOException {
				
				DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
				DocumentBuilder db = dbf.newDocumentBuilder();
				Document dom2 = db.parse("src/s1_defender.xml");
				dom2.getDocumentElement().normalize();
				Element docEle2 = dom2.getDocumentElement();
				Defender defender= null;
				NodeList nl = docEle2.getChildNodes();
				String sourceIP = null;
				if(nl!=null && nl.getLength()>0){
					for (int i = 0; i < nl.getLength(); i++) {
						if(nl.item(i).getNodeType() == Node.ELEMENT_NODE){
							Element el=(Element) nl.item(i);
							sourceIP= el.getAttribute("sourceIP").toString();
							
						}
					}
				}
				
				defender= new Defender(space, grid, sourceIP);
				defender.setSecurityPolicyList(SecurityPolicyListParser.getSecurityPolicyList());
				
				return defender;
			}
		}
	'''
	def compile_HttpDataParser(Agent e)'''
		package jzombies.util;

		import java.util.HashMap;
		
		import jzombies.HttpMethod;
		
		/***
		 * This class parse the data portion of the request
		 * to extract the HTTP headers, and body values
		 *
		 */
		public class HttpDataParser {
		
			/***
			 * This method will parse the data portion
			 * of incoming HTTP request.
			 * @param data 
			 * @return HttpData
			 */
			public HttpData parse(String data){
				HttpData hd = new HttpData();
				
				if(data.length() == 0){
					return null;
				}
				
				
		
					String[] lines = data.split("\n");
					for (String line : lines) {
						line = line.replace("\t", "");
						if(line.toLowerCase().startsWith("get")){
							hd.setMethod(HttpMethod.GET);
							line = line.replace("GET ", "");
							line = line.substring(line.indexOf("?") + 1 , line.indexOf("HTTP/"));
							
							hd.setParam(getParam(line));
							break;
						}else if(line.toLowerCase().startsWith("post")){
							hd.setMethod(HttpMethod.POST);
							String str = lines[lines.length - 1].replace("\t", "");
							hd.setParam(getParam(str));
							break;
						}
		
					
				}
				
				return hd;
			}
			/***
			 * This method will return all the parameters
			 * from the body portion in HTTP requests.
			 * @param par is String
			 * @return HashMap 
			 */
			public HashMap<String, String> getParam(String par){
				HashMap<String, String> params = new HashMap<String, String>();
				String[] lines = par.split("&");
				for (String line : lines) {
					String[] parts = line.split("=");
					if(parts.length == 2 )
					params.put(parts[0], parts[1]);
					else if(parts.length > 2  ){
						String temp = "";
						for (int i = 1; i < parts.length; i++) {
							if(i+1 < parts.length){
								temp += parts[i] + "=";
							}else{
								temp += parts[i];
							}
						}
						
						params.put(parts[0],temp);
					}
				}
				
				return params;
			}
			/***
			 * 
			 * This class contains HTTP header's information
			 * and the body. 
			 *
			 */
			public class HttpData{
				HttpMethod method;
				HashMap<String, String> param;
				String host;
				String agent;
				
				public HttpMethod getMethod() {
					return method;
				}
				public void setMethod(HttpMethod method) {
					this.method = method;
				}
				public HashMap<String, String> getParam() {
					return param;
				}
				public void setParam(HashMap<String, String> param) {
					this.param = param;
				}
				public String getHost() {
					return host;
				}
				public void setHost(String host) {
					this.host = host;
				}
				public String getAgent() {
					return agent;
				}
				public void setAgent(String agent) {
					this.agent = agent;
				}
				
			}
			
		}
	'''
	def compile_SecurityPolicyListParser(Agent e)'''
		package jzombies.util;

		import java.io.IOException;
		import java.util.ArrayList;
		import java.util.HashMap;
		import java.util.Iterator;
		import java.util.Map;
		
		import javax.xml.parsers.DocumentBuilder;
		import javax.xml.parsers.DocumentBuilderFactory;
		import javax.xml.parsers.ParserConfigurationException;
		
		import jzombies.HttpMethod;
		import jzombies.Protocol;
		import jzombies.defender.Condition;
		import jzombies.defender.EndPoint;
		import jzombies.defender.SecurityPolicy;
		import jzombies.defender.SecurityPolicyList;
		import jzombies.defender.action.Action;
		import jzombies.defender.action.BlockSender;
		import jzombies.defender.action.DropRequest;
		import jzombies.defender.action.PassRequst;
		import jzombies.defender.condition.FrequencyCheck;
		import jzombies.defender.condition.HttpMethodCheck;
		import jzombies.defender.condition.HttpParamLengthCheck;
		import jzombies.defender.condition.HttpParamLengthCheck.OpCode;
		import jzombies.defender.condition.HttpRegExpMatchCheck;
		import jzombies.defender.condition.ProtocolCheck;
		import jzombies.defender.condition.SubCondition;
		
		import org.w3c.dom.Document;
		import org.w3c.dom.Element;
		import org.w3c.dom.NodeList;
		import org.xml.sax.SAXException;
		
		
		/**
		 * 
		 * This class will parse the defender.xml file,
		 * and find the security policies 
		 */
		public class SecurityPolicyListParser {
			
			/**
			 * 
			 * This method will find the SecurityPolicies within the defender.xml file,
			 * @return an instance of SecurityPolicy
			 */
		public static SecurityPolicyList getSecurityPolicyList() throws ParserConfigurationException, SAXException, IOException {
				
			    SecurityPolicyList spList= new SecurityPolicyList();
				SecurityPolicy sp=null;
				DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
				DocumentBuilder db = dbf.newDocumentBuilder();
				Document dom2 = db.parse("src/s1_defender.xml");
				dom2.getDocumentElement().normalize();
				Element docEle2 = dom2.getDocumentElement();
		
				NodeList nl2 = docEle2.getElementsByTagName("securityPolicyList");
				EndPoint ep = null;
				ArrayList<Action> tc = new ArrayList<Action>();
				ArrayList<Action> fc = new ArrayList<Action>();
				
				ArrayList<Condition> conditions= new ArrayList<Condition>();
				ArrayList<String> op=new ArrayList<String>();
				for (int i = 0; i < nl2.getLength(); i++) {
					if(nl2.item(i) instanceof Element){
			
						NodeList children = ((Element) nl2.item(i)).getElementsByTagName("securityPolicy");
						
						for (int j = 0; j < children.getLength(); j++) {
							if(children.item(j) instanceof Element){
								ep= getEndPoint(children, j);
								
								tc=getTrueActionPortion(children, j);
		
								fc=getFalseActionPortion(children, j);
								
								sp = new SecurityPolicy(ep,tc,fc);
								
								conditions=getPolicies(docEle2, children, j);
								
								for (Condition condition : conditions) {
									sp.addCondition(condition);
								}
		
								op=getOperators(children, j);
								sp.setOperationList(op);
								
								spList.addSecurityPolicy(sp);
							}
		
						}
						
					}
				}
				return spList;
			}
			
			/**
			 * 
			 * This method will find the port and protocol for the security policy,
			 * @param children NodeList 
			 * @param j index
			 * @return an instance of Endpoint
			 */
			private static EndPoint getEndPoint(NodeList children, int j) {
				
				EndPoint ep = new EndPoint();
				NodeList endPointChildren= ((Element)children.item(j)).getElementsByTagName("endpoint");
				HashMap<String, Integer> hmap= new HashMap<String,Integer>();
				Protocol protocol = null; 
				Integer port = 0;
				for (int k = 0; k < endPointChildren.getLength(); k++) {
					if (endPointChildren.item(k) instanceof Element) {
						Element e= (Element) endPointChildren.item(k);
						String value=e.getElementsByTagName("protocol").item(k).getTextContent().toUpperCase();
						protocol = getProtocol(value);
						port= Integer.parseInt(e.getElementsByTagName("port").item(k).getTextContent());
						hmap.put("protocol", protocol.getStatusCode());
						hmap.put("port", Integer.parseInt(e.getElementsByTagName("port").item(k).getTextContent()));
					}       
				}
				ep.setProtocol(protocol);
				ep.setPort(port);
				return ep;
			}
			
			/**
			 * 
			 * This method will find the allowed behaviors for the policies,
			 * @param children NodeList 
			 * @param j index
			 * @return an array list of Action
			 */
			private static ArrayList<Action> getTrueActionPortion(NodeList children, int j) {
				ArrayList<Action> tc= new ArrayList<Action>();
				NodeList trueActionChildren= ((Element)children.item(j)).getElementsByTagName("trueAction");
				for (int k = 0; k < trueActionChildren.getLength(); k++) {
					if (trueActionChildren.item(k) instanceof Element) {
						Element actionElement= (Element)trueActionChildren.item(k);
						for (int l = 0; l < actionElement.getElementsByTagName("action").getLength(); l++) {
							
							String actionName=actionElement.getElementsByTagName("action").item(l).getAttributes().getNamedItem("type").getNodeValue();
							if(actionName.equalsIgnoreCase("pass")){ 
								tc.add(new PassRequst());
							}
							else if(actionName.equalsIgnoreCase("drop")){
								tc.add(new DropRequest());
							}else{
								tc.add(new BlockSender());
							}
						}
					}
				}
				return tc;
			}
			
			/**
			 * 
			 * This method will find the disallowed behaviors for the policies,
			 * @param children NodeList 
			 * @param j index
			 * @return an array list of Action
			 */
			private static ArrayList<Action> getFalseActionPortion(NodeList children, int j) {
				ArrayList<Action> fc= new ArrayList<Action>();
				NodeList falseActionChildren= ((Element)children.item(j)).getElementsByTagName("falseAction");
				for (int k = 0; k < falseActionChildren.getLength(); k++) {
					if (falseActionChildren.item(k) instanceof Element) {
						Element falseAction= (Element)falseActionChildren.item(k);
						for (int l = 0; l < falseAction.getElementsByTagName("action").getLength(); l++) {
							String actionName=falseAction.getElementsByTagName("action").item(l).getAttributes().getNamedItem("type").getNodeValue();
							if(actionName.equalsIgnoreCase("pass")){
								fc.add(new PassRequst());
							}
							else if(actionName.equalsIgnoreCase("drop")){
								fc.add(new DropRequest());
							}else{
								fc.add(new BlockSender());
							}
						}
					}
				}
				return fc;
			}
			
			/**
			 * 
			 * This method will find the security policies within the defender.xml,
			 * @param docEle2 SecurityPolicyList element under the defender node
			 * @param children NodeList 
			 * @param j index
			 * @return a hash map of conditions for each security policy
			 * 
			 */
			private static ArrayList<Condition> getPolicies(Element docEle2, NodeList children, int j) {
		
				ArrayList<Condition> conditionsList= new ArrayList<Condition>();
				HashMap<String, Condition> conditionHashMap = getConditions(children, j);	
			
				HashMap<String, ArrayList<SubCondition>> subConditionHashMap=getSubConditions(docEle2);
				
			
				
						Iterator iter = conditionHashMap.entrySet().iterator();
						while (iter.hasNext()) {
							Map.Entry mEntry = (Map.Entry) iter.next();//conditions
							
							
							Iterator iter2 = subConditionHashMap.entrySet().iterator();
							while (iter2.hasNext()) {
								Map.Entry mEntry2 = (Map.Entry) iter2.next();//subconditions
								if(mEntry.getKey().toString().equals(mEntry2.getKey().toString())){
									
									for (SubCondition sub: (ArrayList<SubCondition>)mEntry2.getValue() ){
										((Condition)mEntry.getValue()).addSubCondition(sub);
									}
								
									//conditionsList.add(((Condition)mEntry.getValue()));
								}				
							}
							conditionsList.add(((Condition)mEntry.getValue()));
						}
						return conditionsList;
		
			}
			
			/**
			 * 
			 * This method will find the conditions for each security policy 
			 * within the defender.xml,
			 * @param children NodeList 
			 * @param j index
			 * @return a hash map of conditions for each security policy
			 * 
			 */
			private static HashMap<String, Condition> getConditions(NodeList children,
					int j) {
				HashMap<String, Condition> conditionHashMap= new HashMap<String, Condition>();
				NodeList policy= ((Element)children.item(j)).getElementsByTagName("policy");
				for (int k = 0; k < policy.getLength(); k++) {
					if (policy.item(k) instanceof Element) {
						Element cond= (Element)policy.item(k);
						String policyName;
						//System.out.println(cond.getElementsByTagName("condition").getLength());
						for (int l = 0; l < cond.getElementsByTagName("condition").getLength(); l++) {
							policyName=cond.getElementsByTagName("condition").item(l).getAttributes().getNamedItem("name").getNodeValue();
		
							Condition c1= new Condition();
		
							conditionHashMap.put(policyName, c1);
						}
					}
				}
				return conditionHashMap;
			}
			
			/**
			 * 
			 * This method will find the subconditions within the defender.xml,
			 * @param docEle2 SecurityPolicyList element under the defender node
			 * @return a hash map of subconditions list for each condition
			 * 
			 */
			private static HashMap<String, ArrayList<SubCondition> > getSubConditions(Element docEle2) {
				
				
				
				HashMap<String, ArrayList<SubCondition> > subconditionHashMap= new HashMap<String, ArrayList<SubCondition> >();
				NodeList conditionListNodes = docEle2.getElementsByTagName("conditionList");
				for (int m = 0; m < conditionListNodes.getLength(); m++) {
					if(conditionListNodes.item(m) instanceof Element){
						NodeList conditions = ((Element)conditionListNodes.item(m)).getElementsByTagName("condition");
						for (int i = 0; i < conditions.getLength(); i++) {
							if(conditions.item(i) instanceof Element){
								String conditionName= conditions.item(i).getAttributes().getNamedItem("name").getNodeValue();
								
								NodeList subConditions= ((Element) conditions.item(i)).getElementsByTagName("subcondition");
								for (int k = 0; k < subConditions.getLength(); k++) {
									if(subConditions.item(k) instanceof Element){
										String subConditionsName= subConditions.item(k).getAttributes().getNamedItem("name").getNodeValue();
										String subConditionsValue= subConditions.item(k).getTextContent().toString().trim();
										//System.out.println("conditionName:" +conditionName +"--> " +"subConditionsName: " + subConditionsName +"subConditionsValue: "  + subConditionsValue);
										if(subConditionsName.equals("isRequestProtocolEqualsTo")){
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new ProtocolCheck(getProtocol(subConditionsValue)));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new ProtocolCheck(getProtocol(subConditionsValue)));
											}
											
										}
										else if(subConditionsName.equals("isHTTPMethodEqualsTo")){				
											//subconditionHashMap.put(conditionName, new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											}
											
										}
										else if(subConditionsName.equals("isParaContentMatchRegExp")){				
											//subconditionHashMap.put(conditionName, new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new HttpRegExpMatchCheck(subConditionsValue));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new HttpRegExpMatchCheck(subConditionsValue));
											}
											
										}
										
										else if(subConditionsName.equals("isRequestFrequencyLessThan")){				
											//subconditionHashMap.put(conditionName, new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new FrequencyCheck(Integer.parseInt(subConditionsValue)));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new FrequencyCheck(Integer.parseInt(subConditionsValue)));
											}		
										}
										else if(subConditionsName.equals("isParaLenghtLessThan")){				
											//subconditionHashMap.put(conditionName, new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new HttpParamLengthCheck(OpCode.LessThan, Integer.parseInt(subConditionsValue)));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new HttpParamLengthCheck(OpCode.LessThan, Integer.parseInt(subConditionsValue)));
											}		
										}
										
										else if(subConditionsName.equals("isParaLenghtGreaterThan")){				
											//subconditionHashMap.put(conditionName, new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new HttpParamLengthCheck(OpCode.GreaterThan, Integer.parseInt(subConditionsValue)));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new HttpParamLengthCheck(OpCode.GreaterThan, Integer.parseInt(subConditionsValue)));
											}		
										}
										
										else if(subConditionsName.equals("isParaLenghtEqualsTo")){				
											//subconditionHashMap.put(conditionName, new HttpMethodCheck(getHTTPMethod(subConditionsValue)));
											
											if(subconditionHashMap.containsKey(conditionName)){
												subconditionHashMap.get(conditionName).add(new HttpParamLengthCheck(OpCode.EqualsTo, Integer.parseInt(subConditionsValue)));
											}else{
												ArrayList<SubCondition> templist = new ArrayList<SubCondition>();
												
												subconditionHashMap.put(conditionName, templist);
												templist.add(new HttpParamLengthCheck(OpCode.EqualsTo, Integer.parseInt(subConditionsValue)));
											}		
										}
									}
								}
								
								
							}
						}
						
					}				
		
				}
				return subconditionHashMap;
			}
		
			/**
			 * 
			 * This method will find the operators for the conditions,
			 * @param children NodeList 
			 * @param j index
			 * @return the string[operators] of arraylist
			 * 
			 */
			private static ArrayList<String> getOperators(NodeList children, int j) {
				ArrayList<String> operatorList= new ArrayList<String>();
				NodeList operatorListChildren= ((Element)children.item(j)).getElementsByTagName("operationList");
				for (int k = 0; k < operatorListChildren.getLength(); k++) {
					if (operatorListChildren.item(k) instanceof Element) {
						Element actionElement= (Element)operatorListChildren.item(k);
						for (int l = 0; l < actionElement.getElementsByTagName("operator").getLength(); l++) {
							operatorList.add(actionElement.getElementsByTagName("operator").item(l).getTextContent());
							
						}
					}
				}
				return operatorList;
			}
			
			/**
			 * 
			 * This method will find the protocol,
			 * @param value the string value found within the xml file
			 * @return the matched protocol [HTTP(80) HTTPS(443) FTP(21) SSH(22)]
			 * 
			 */
			private static Protocol getProtocol(String value) {
				Protocol pro = null;		
				for (Protocol b : Protocol.values()) {
					if (value.equals((b.toString().toUpperCase()))) {
						pro= b;
						break;
					}
				}
				return pro;
			}
			
			/**
			 * 
			 * This method will find the http method,
			 * @param value the string value found within the xml file
			 * @return the matched http method; [GET,POST,HEAD,DELETE,PUT]
			 * 
			 */
			private static HttpMethod getHTTPMethod(String value) {
				HttpMethod method = null;		
				for (HttpMethod m : HttpMethod.values()) {
					if (value.toUpperCase().equals((m.toString().toUpperCase()))) {
						method= m;
						break;
					}
				}
				return method;
			}
				
		}
	'''
	def compile_UserAndAttackerParser(Agent e)'''
		package jzombies.util;

		import java.io.IOException;
		import java.util.ArrayList;
		
		import javax.xml.parsers.DocumentBuilder;
		import javax.xml.parsers.DocumentBuilderFactory;
		import javax.xml.parsers.ParserConfigurationException;
		
		import org.w3c.dom.Document;
		import org.w3c.dom.Element;
		import org.w3c.dom.Node;
		import org.w3c.dom.NodeList;
		import org.xml.sax.SAXException;
		
		import jzombies.Agent;
		import jzombies.Attacker;
		import jzombies.Protocol;
		import jzombies.Request;
		import jzombies.User;
		import repast.simphony.space.continuous.ContinuousSpace;
		import repast.simphony.space.grid.Grid;
		
		/**
		 * This class will parse the Users.xml file,
		 * to find the user and attacker
		 */
		public class UserAndAttackerParser{
		
		
			/**
			 * 
			 * This method will parse the Users.xml file,
			 * look for the defender
			 * @param space ContinuousSpace
			 * @param grid Grid
			 * @return an ArrayList of agents that include instance
			 * of User and Attacker
			 */
			public ArrayList<Agent> parseUsers(ContinuousSpace<Object> space,
					Grid<Object> grid)
							throws ParserConfigurationException, SAXException, IOException {
				ArrayList<Agent> agentsList = new ArrayList<Agent>();
				DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
				DocumentBuilder db = dbf.newDocumentBuilder();
		
				Document dom = db.parse("src/s1_Users.xml");
				dom.getDocumentElement().normalize();
				Element docEle = dom.getDocumentElement();
		
		
				NodeList nl = docEle.getChildNodes();
				boolean isUser = false;
		
				if(nl!=null && nl.getLength()>0){
					for (int i = 0; i < nl.getLength(); i++) {
						if(nl.item(i).getNodeType() == Node.ELEMENT_NODE){
							Element el=(Element) nl.item(i);
							if(el.getNodeName().toUpperCase().contains("USER")){
		
								isUser = el.getAttribute("type").toUpperCase().contains("USER");
		
								ArrayList<Request> rl = new ArrayList<Request>();
		
								for (int j = 0; j < el.getElementsByTagName("request").getLength(); j++) {
									String protocol=el.getElementsByTagName("protocol").item(j).getTextContent().toUpperCase();
		
									Protocol pro = getProtocol(protocol);
									rl.add(new Request(el.getElementsByTagName("source").item(j).getTextContent().replace("\t", ""), el.getElementsByTagName("destination").item(j).getTextContent().replace("\t", ""), Integer.parseInt(el.getElementsByTagName("port").item(j).getTextContent()), el.getElementsByTagName("data").item(j).getTextContent().replace("\t", ""), pro));
								}
								if(isUser){
									User u = new User(space,grid,el.getAttribute("sourceIP"));
									for (Request request : rl) {
										u.addRequest(request);
									}
		
									agentsList.add(u);
								}
								else{
									Attacker u = new Attacker(space,grid,el.getAttribute("sourceIP"));
									for (Request request : rl) {
										u.addRequest(request);
									}
									//u.print();
									agentsList.add(u);
		
								}
							}
						}
					}
		
				}
				return agentsList;
			}
		
			/**
			 * 
			 * This method will find the protocol,
			 * @param value the string value found within the xml file
			 * @return the matched protocol
			 * 
			 */
			private static Protocol getProtocol(String value) {
				Protocol pro = null;		
				for (Protocol b : Protocol.values()) {
					if (value.equals((b.toString().toUpperCase()))) {
						pro= b;
						break;
					}
				}
				return pro;
			}
		
		
		}
	'''
}
