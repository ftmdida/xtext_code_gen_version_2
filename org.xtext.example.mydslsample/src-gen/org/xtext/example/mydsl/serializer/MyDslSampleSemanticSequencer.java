/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDslSample.Attacker;
import org.xtext.example.mydsl.myDslSample.BlockSender;
import org.xtext.example.mydsl.myDslSample.Condition;
import org.xtext.example.mydsl.myDslSample.Defender;
import org.xtext.example.mydsl.myDslSample.DropRequest;
import org.xtext.example.mydsl.myDslSample.EndPoint;
import org.xtext.example.mydsl.myDslSample.FrequencyCheck;
import org.xtext.example.mydsl.myDslSample.HTTPMethodCheck;
import org.xtext.example.mydsl.myDslSample.HTTPParamLenCheck;
import org.xtext.example.mydsl.myDslSample.HttpShieldModel;
import org.xtext.example.mydsl.myDslSample.IPAddress;
import org.xtext.example.mydsl.myDslSample.MaliciousRequest;
import org.xtext.example.mydsl.myDslSample.MyDslSamplePackage;
import org.xtext.example.mydsl.myDslSample.NormalRequest;
import org.xtext.example.mydsl.myDslSample.PassRequest;
import org.xtext.example.mydsl.myDslSample.ProtocolCheck;
import org.xtext.example.mydsl.myDslSample.RegExpMatch;
import org.xtext.example.mydsl.myDslSample.SecurityPolicy;
import org.xtext.example.mydsl.myDslSample.SecurityPolicyList;
import org.xtext.example.mydsl.myDslSample.User;
import org.xtext.example.mydsl.services.MyDslSampleGrammarAccess;

@SuppressWarnings("all")
public class MyDslSampleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslSampleGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == MyDslSamplePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case MyDslSamplePackage.ATTACKER:
				sequence_Attacker(context, (Attacker) semanticObject); 
				return; 
			case MyDslSamplePackage.BLOCK_SENDER:
				sequence_BlockSender(context, (BlockSender) semanticObject); 
				return; 
			case MyDslSamplePackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MyDslSamplePackage.DEFENDER:
				sequence_Defender(context, (Defender) semanticObject); 
				return; 
			case MyDslSamplePackage.DROP_REQUEST:
				sequence_DropRequest(context, (DropRequest) semanticObject); 
				return; 
			case MyDslSamplePackage.END_POINT:
				sequence_EndPoint(context, (EndPoint) semanticObject); 
				return; 
			case MyDslSamplePackage.FREQUENCY_CHECK:
				sequence_FrequencyCheck(context, (FrequencyCheck) semanticObject); 
				return; 
			case MyDslSamplePackage.HTTP_METHOD_CHECK:
				sequence_HTTPMethodCheck(context, (HTTPMethodCheck) semanticObject); 
				return; 
			case MyDslSamplePackage.HTTP_PARAM_LEN_CHECK:
				sequence_HTTPParamLenCheck(context, (HTTPParamLenCheck) semanticObject); 
				return; 
			case MyDslSamplePackage.HTTP_SHIELD_MODEL:
				sequence_HttpShieldModel(context, (HttpShieldModel) semanticObject); 
				return; 
			case MyDslSamplePackage.IP_ADDRESS:
				sequence_IPAddress(context, (IPAddress) semanticObject); 
				return; 
			case MyDslSamplePackage.MALICIOUS_REQUEST:
				sequence_MaliciousRequest(context, (MaliciousRequest) semanticObject); 
				return; 
			case MyDslSamplePackage.NORMAL_REQUEST:
				sequence_NormalRequest(context, (NormalRequest) semanticObject); 
				return; 
			case MyDslSamplePackage.PASS_REQUEST:
				sequence_PassRequest(context, (PassRequest) semanticObject); 
				return; 
			case MyDslSamplePackage.PROTOCOL_CHECK:
				sequence_ProtocolCheck(context, (ProtocolCheck) semanticObject); 
				return; 
			case MyDslSamplePackage.REG_EXP_MATCH:
				sequence_RegExpMatch(context, (RegExpMatch) semanticObject); 
				return; 
			case MyDslSamplePackage.SECURITY_POLICY:
				sequence_SecurityPolicy(context, (SecurityPolicy) semanticObject); 
				return; 
			case MyDslSamplePackage.SECURITY_POLICY_LIST:
				sequence_SecurityPolicyList(context, (SecurityPolicyList) semanticObject); 
				return; 
			case MyDslSamplePackage.USER:
				sequence_User(context, (User) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (type='Attacker' name=ID filename=STRING source=IPAddress requests+=MaliciousRequest*)
	 */
	protected void sequence_Attacker(EObject context, Attacker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     action='block'
	 */
	protected void sequence_BlockSender(EObject context, BlockSender semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.ACTION__ACTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBlockSenderAccess().getActionBlockKeyword_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID subConditionList+=SubCondition subConditionList+=SubCondition*)
	 */
	protected void sequence_Condition(EObject context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type='Defender' name=ID filename=STRING source=IPAddress securityPolicylist=SecurityPolicyList)
	 */
	protected void sequence_Defender(EObject context, Defender semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.AGENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.AGENT__TYPE));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.AGENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.AGENT__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.AGENT__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.AGENT__FILENAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.AGENT__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.AGENT__SOURCE));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.DEFENDER__SECURITY_POLICYLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.DEFENDER__SECURITY_POLICYLIST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDefenderAccess().getTypeDefenderKeyword_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDefenderAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefenderAccess().getFilenameSTRINGTerminalRuleCall_4_0(), semanticObject.getFilename());
		feeder.accept(grammarAccess.getDefenderAccess().getSourceIPAddressParserRuleCall_6_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getDefenderAccess().getSecurityPolicylistSecurityPolicyListParserRuleCall_7_0(), semanticObject.getSecurityPolicylist());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     action='drop'
	 */
	protected void sequence_DropRequest(EObject context, DropRequest semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.ACTION__ACTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDropRequestAccess().getActionDropKeyword_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (port=INT protocol=Protocol)
	 */
	protected void sequence_EndPoint(EObject context, EndPoint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.END_POINT__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.END_POINT__PORT));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.END_POINT__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.END_POINT__PROTOCOL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEndPointAccess().getPortINTTerminalRuleCall_2_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getEndPointAccess().getProtocolProtocolEnumRuleCall_4_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name='isRequestFrequencyLessThan' value=INT)
	 */
	protected void sequence_FrequencyCheck(EObject context, FrequencyCheck semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.SUB_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.SUB_CONDITION__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.FREQUENCY_CHECK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.FREQUENCY_CHECK__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFrequencyCheckAccess().getNameIsRequestFrequencyLessThanKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFrequencyCheckAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name='isHTTPMethodEqualsTo' (value='GET' | value='POST' | value='HEAD' | value='DELETE' | value='PUT'))
	 */
	protected void sequence_HTTPMethodCheck(EObject context, HTTPMethodCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name='isParaLenghtLessThan' value=INT) | (name='isParaLenghtGreaterThan' value=INT) | (name='isParaLenghtEqualsTo' value=INT))
	 */
	protected void sequence_HTTPParamLenCheck(EObject context, HTTPParamLenCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     agents+=Agent*
	 */
	protected void sequence_HttpShieldModel(EObject context, HttpShieldModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (byte1=INT byte2=INT byte3=INT byte4=INT)
	 */
	protected void sequence_IPAddress(EObject context, IPAddress semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE1));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE2));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE3));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE4) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.IP_ADDRESS__BYTE4));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIPAddressAccess().getByte1INTTerminalRuleCall_0_0(), semanticObject.getByte1());
		feeder.accept(grammarAccess.getIPAddressAccess().getByte2INTTerminalRuleCall_2_0(), semanticObject.getByte2());
		feeder.accept(grammarAccess.getIPAddressAccess().getByte3INTTerminalRuleCall_4_0(), semanticObject.getByte3());
		feeder.accept(grammarAccess.getIPAddressAccess().getByte4INTTerminalRuleCall_6_0(), semanticObject.getByte4());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         source=IPAddress 
	 *         destination=IPAddress 
	 *         port=INT 
	 *         data=STRING 
	 *         protocol=Protocol
	 *     )
	 */
	protected void sequence_MaliciousRequest(EObject context, MaliciousRequest semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__SOURCE));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__DESTINATION));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__PORT));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__DATA));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__PROTOCOL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMaliciousRequestAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaliciousRequestAccess().getSourceIPAddressParserRuleCall_4_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getMaliciousRequestAccess().getDestinationIPAddressParserRuleCall_6_0(), semanticObject.getDestination());
		feeder.accept(grammarAccess.getMaliciousRequestAccess().getPortINTTerminalRuleCall_8_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getMaliciousRequestAccess().getDataSTRINGTerminalRuleCall_10_0(), semanticObject.getData());
		feeder.accept(grammarAccess.getMaliciousRequestAccess().getProtocolProtocolEnumRuleCall_12_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         source=IPAddress 
	 *         destination=IPAddress 
	 *         port=INT 
	 *         data=STRING 
	 *         protocol=Protocol
	 *     )
	 */
	protected void sequence_NormalRequest(EObject context, NormalRequest semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__SOURCE));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__DESTINATION));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__PORT));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__DATA));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REQUEST__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REQUEST__PROTOCOL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNormalRequestAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNormalRequestAccess().getSourceIPAddressParserRuleCall_4_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getNormalRequestAccess().getDestinationIPAddressParserRuleCall_6_0(), semanticObject.getDestination());
		feeder.accept(grammarAccess.getNormalRequestAccess().getPortINTTerminalRuleCall_8_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getNormalRequestAccess().getDataSTRINGTerminalRuleCall_10_0(), semanticObject.getData());
		feeder.accept(grammarAccess.getNormalRequestAccess().getProtocolProtocolEnumRuleCall_12_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     action='pass'
	 */
	protected void sequence_PassRequest(EObject context, PassRequest semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.ACTION__ACTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPassRequestAccess().getActionPassKeyword_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name='isRequestProtocolEqualsTo' value=Protocol)
	 */
	protected void sequence_ProtocolCheck(EObject context, ProtocolCheck semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.SUB_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.SUB_CONDITION__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.PROTOCOL_CHECK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.PROTOCOL_CHECK__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProtocolCheckAccess().getNameIsRequestProtocolEqualsToKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProtocolCheckAccess().getValueProtocolEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name='isParaContentMatchRegExp' value=STRING)
	 */
	protected void sequence_RegExpMatch(EObject context, RegExpMatch semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.SUB_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.SUB_CONDITION__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslSamplePackage.Literals.REG_EXP_MATCH__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslSamplePackage.Literals.REG_EXP_MATCH__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRegExpMatchAccess().getNameIsParaContentMatchRegExpKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRegExpMatchAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID securityPolicies+=SecurityPolicy* conditions+=Condition*)
	 */
	protected void sequence_SecurityPolicyList(EObject context, SecurityPolicyList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         endPoint=EndPoint 
	 *         conditionlist+=[Condition|ID] 
	 *         ((operationList+='&' | operationList+='|') conditionlist+=[Condition|ID])* 
	 *         trueActionList+=Action 
	 *         trueActionList+=Action* 
	 *         falseActionList+=Action 
	 *         falseActionList+=Action*
	 *     )
	 */
	protected void sequence_SecurityPolicy(EObject context, SecurityPolicy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type='User' name=ID filename=STRING source=IPAddress requests+=NormalRequest*)
	 */
	protected void sequence_User(EObject context, User semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
